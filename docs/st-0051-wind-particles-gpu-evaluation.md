# [ST-0051] （v1）风粒子流（GPU）方案评估

更新时间：2026-01-20

## 目标

评估在 Web / UE 端实现“风粒子流（GPU particle flow）”的可行性、性能边界与实现路径，给出推荐方案与约束（粒子数/分辨率/带宽）。

> 说明：本文聚焦技术方案与工程落地路径；不展开 UI 交互细节。

---

## 1) 问题拆解

风粒子流可分为 3 个阶段：

1. **速度场输入**：在屏幕空间或地理空间获取 `u/v`（或速度向量纹理）。
2. **粒子仿真**：对粒子位置做积分（Euler/RK2/RK4），并做生命周期/重生。
3. **粒子渲染**：以点精灵/线段/拖尾的方式绘制，并控制混合/透明度。

瓶颈通常不在着色器算力，而在：
- 速度场纹理的分辨率与更新频率（网络/解码/上传 GPU）
- 粒子数与屏幕 fill-rate（尤其是拖尾与高透明叠加）

---

## 2) Web 端方案对比

### A. WebGL2（推荐 v1）

**核心思路**：将速度场编码为 GPU texture；粒子位置用 float texture（ping-pong）；用 fragment shader 更新粒子，用 vertex shader 渲染点。

优点：
- 浏览器覆盖面最好（Chrome/Edge/Firefox/Safari 现代版本普遍支持 WebGL2）
- 工程成熟，参考实现丰富
- 粒子 50k~200k 级别在中高端 GPU 上可达可用帧率（取决于分辨率与拖尾）

风险/限制：
- 需要 `EXT_color_buffer_float` / `OES_texture_float_linear` 等扩展来获得更高质量插值与更大粒子规模（需做能力检测与降级）
- 与 Cesium 场景合成需要设计（Overlay canvas / WebGL context 共享困难）

建议落地策略：
- **独立 WebGL2 canvas overlay**：不与 Cesium 共用 context，降低耦合；用相机矩阵把粒子映射到屏幕（或直接做屏幕空间流场）
- 速度场：先用低分辨率（如 256² / 512²）验证，支持按视野 bbox 拉取

### B. WebGPU（可作为 v2）

**核心思路**：compute shader 更新粒子 buffer，render pipeline 绘制；更接近原生图形管线。

优点：
- 结构更清晰，性能上限更高（特别是大量粒子、复杂拖尾、后处理）
- buffer/texture 管理更强，适合做更复杂的流体/噪声扰动

风险/限制：
- 兼容性与落地成本更高（Safari/部分环境受限）
- Cesium 主渲染仍是 WebGL，双栈维护成本高

结论：
- v1 不建议押注 WebGPU；可保留为“高级模式/实验开关”。

---

## 3) UE 端方案（Niagara）

推荐使用 Niagara + 速度场采样：
- 速度场来源：CPU 侧按区域生成 2D/3D 速度场纹理（或体纹理），或从服务端下发。
- Niagara 中用采样得到速度矢量，更新粒子速度/位置。

注意点：
- 需要明确速度场坐标系（世界坐标 vs 地理坐标投影）与重采样策略
- 若速度场来自服务端，带宽与更新频率是主要成本项

---

## 4) 推荐方案与约束（建议）

### v1 推荐
- Web：**WebGL2 纹理粒子（overlay canvas）**
- UE：Niagara（按需实现）

### 建议的默认参数范围（经验值）
- 速度场分辨率：`256×256`（默认）到 `512×512`（高质量）
- 粒子数：
  - 默认：`50k`
  - 性能模式：`20k`
  - 高端设备：`100k~200k`（需压测）
- 拖尾长度：1~8 帧（拖尾越长越吃 fill-rate）

### 必须支持的降级策略
- 不支持 WebGL2 / float render target → 回退到 CPU 简化粒子（或禁用）
- 帧率低于阈值 → 自动降低粒子数/速度场分辨率/拖尾

---

## 5) 后续实现路径（建议拆分）

1. WebGL2 PoC：静态速度场纹理 + 50k 粒子
2. 速度场接入：从 `API bbox + time + level` 拉取并更新纹理
3. 与 Cesium 合成：叠加层对齐相机/视野
4. 性能自适应：粒子数/分辨率动态调参

